 

# JVM探究

- 请你谈谈你对JVM的理解?java8虚拟机和之前的变化更新? 
- 什么是OOM，什么是栈溢出StackOverFlowError?怎么分析?
- JVM的常用调优参数有哪些?
- 内存快照如何抓取，怎么分析Dump文件?知道吗?
- 谈谈JVM中，类加载器你的认识?







## 1、JVM的位置

![image-20220704150349663](jvm.assets/image-20220704150349663.png)



## 2、JVM的体系结构

![image-20220614161421530](jvm.assets/image-20220614161421530.png)

运行时数据区可分为两部分：**线程私有区和线程共享区**。

线程私有区主要包含三个区域：**虚拟机栈**，**本地方法栈**，**程序计数器**。

注意的是，在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈

线程共享区主要包含：堆区，方法区。



### 1、程序计数器

程序计数器是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器

在虚拟机的概念模型里，字节码解释器工作时就是通过程序计数器的值来选定下一条需要执行的字节码指令

由于java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任一时刻，一个处理器（一个内核）都只会执行一条线程中的指令。所以为了线程切换后能够恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器。所以归为“线程私有”



### 2、Java虚拟机栈

Java虚拟机栈也是线程私有的，他的生命周期和线程相同。

虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息

每一个方法从调用直到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程

对于程序猿来说，最看重的还是堆内存和栈内存，其中的栈内存就是虚拟机栈，或者说是虚拟机栈中局部变量表部分

局部变量表中存放课编译期可知的各种基本数据类型，对象引用和returnAddress（指向了一条字节码指令的地址）

局部变量表的单位为Slot，其中64位长度的long，double占用2个Slot，其余的占一个，局部变量表的内存空间是编译期间完成分配的

当进入一个方法时这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

在Java规范中，对这个区域规定了两种异常情况：

- 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；
- 如果虚拟机栈可以动态扩展，并且在扩展时无法申请到足够的内存，会抛出OutOfMemoryError异常





### 3、本地方法栈

本地方法栈为使用到的Native方法服务

凡带了`Native`关键字的，说明java的作用范围达不到了，回去调用底层C语言的库!

它在内存区域中专门开辟了一块标记区域:Native Method Stack，登记 native 方法在最终执行的时候，加载本地方法库中的方法通过JNI

调用本地方法本地接口JNI  （Java Native Interface ，Java本地方法接口)，JNI作用:扩展Java的使用，融合不同的编程语言为Java所用! 最初:C、C++。



### 4、java堆

java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建

此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存 

在《java虚拟机规范》中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着技术的的发展，所有的对象都分配在堆上也渐渐变得不是那么绝对了。

Java堆是垃圾收集器管理的主要区域。

从内存回收的角度上看，由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间，From Survivor空间，To Survivor空间等

从内存分配的角度上看，线程共享的Java堆中可能划分多个线程私有的分配缓冲区

根据Java虚拟机规范的约定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的就可以了。

当前主流的虚拟机都是按照可扩展来实现的（-Xmx，-Xms），如果没有内存完成实例分配，堆也无法在扩展时，将会抛出OutOfMemoryError





### 5、方法区

方法区和Java堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息，常量，静态变量等数据，所有定义的方法的信息都保存在该区域

这里要区分永久代和方法区两个概念，仅仅是用实现永久代的方式实现方法区而已，这样做是为了HotSpot的垃圾收集器能像管理Java堆一样管理这部分的内存，能够省去专门为方法区编写内存管理代码的工作，这属于实现细节。

不过HotSpot虚拟机现在也有放弃永久代并逐步改为采用Native Memory来实现方法区的规划了

在JDK6的时候就有这个计划了，到了JDK7已经把原本放在永久代的字符串常量池移出，带了JDK8，终于完全废弃了永久代这个概念，在本地内存中实现了元空间来代替。



#### 5.1、运行时常量池

运行时常量池是方法区的一部分，主要用于存储Class文件中的常量池 -> 存放的编译期生成的各种字面量和符号引用

运行时常量池相对于Class文件常量池的一个重要特征是具备动态性

Java语言不要求常量一定只有编译期才会产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中 -> String类的intern()方法。

运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法在申请到内存时会抛出OutOfMemoryError异常





### 6、直接内存

直接内存不是虚拟机运行时数据区的一部分，但是这部分内存也被频繁地使用，而且也可能导致OOM，所以放在这里一起讲

在JDK1.4引入了NIO（New Input/Output）类，引入了一种基于通道和缓存区的I/O方式

它可以使用Native函数直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，这就避免了Java堆和Native堆中来回复制数据。

直接内存不会受到Java堆大小的限制。



### 7、实验OOM异常

在Java虚拟机规范的描述中，除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OOM的可能。

我们根据HotSpot虚拟机，来进行实验



> Java堆溢出

Java堆是用来存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清楚这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。

我们来试试下面的例子

```java
/**
 * -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError
 */
public class MyTest {

    static class OOMObject{}

    public static void main(String[] args) {
        List<OOMObject> list = new ArrayList<>();
        while(true){
            list.add(new OOMObject());
        }
    }
}
```

运行结果：

![image-20221022110917064](jvm.assets/image-20221022110917064.png)

这时候通过MAT（Memory Analyzer）打开dump文件，重点是确定是内存泄露还是内存溢出

![image-20221022111232456](jvm.assets/image-20221022111232456.png)

如果是内存泄露，可进一步通过工具查看泄露对象到GC Root 引用链的信息 ，就可以比较准确地定位出泄露代码的位置。

如果是内存溢出，那就应该检查虚拟机的堆参数（-Xmx 与 -Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象声明周期过长，持有状态时间过长的情况，尝试减少程序运行期的内存消耗。



> 虚拟机栈和本地方法栈溢出

由于HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此，对于HotSpot爱说，虽然 -Xoss参数（设置本地方法栈大小）存在，但实际上是无效的。

栈容量只由 -Xss参数设定。

关于虚拟机栈和本地方法栈，在Java虚拟机规范中描述了两种异常：

- 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverFlowError异常
- 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常

《Java虚拟机规范》明确允许JVM实现自行选择是否支持栈的动态扩展，而HotSpot虚拟机的选择是不支持扩展，所以除非在创建线程申请内存时就因无法获得足够内存而出现OOM，否则在线程运行时是不会因为扩展而导致内存溢出的，只会因为栈容量无法容纳新的栈帧而导致StackOverflowError。

我们来看看是否能让HotSpot OOM：

使用-Xss减少栈内存容量

```java
/**
 * -Xss128k -XX:+HeapDumpOnOutOfMemoryError
 */
public class MyTest {

    private int stackLength = 1;

    public void stackLeak() {
        stackLength ++;
        stackLeak();
    }

    public static void main(String[] args) {
        MyTest myTest = new MyTest();
        try {
            myTest.stackLeak();
        } catch (Throwable e) {
            System.out.println("stack length: " + myTest.stackLength);
            throw e;
        }
    }
}
```

运行结果：

![image-20221022114458637](jvm.assets/image-20221022114458637.png)



定义大量局部变量，增大此方法帧中本地变量表的长度

```java
public class MyTest2 {


    private static int stackLength = 0;

    public static void test(){
        long unUser1, unUser2, unUser3, unUser4, unUser5, unUser6, unUser7, unUser8, unUser9, unUser10,
        unUser11, unUser12, unUser13, unUser14, unUser15, unUser16, unUser17, unUser18, unUser19, unUser20,
        unUser21, unUser22, unUser23, unUser24, unUser25, unUser26, unUser27, unUser28, unUser29, unUser30,
        unUser31, unUser32, unUser33, unUser34, unUser35, unUser36, unUser37, unUser38, unUser39, unUser40,
        unUser41, unUser42, unUser43, unUser44, unUser45, unUser46, unUser47, unUser48, unUser49, unUser50;
        stackLength ++;
        test();
        unUser1 = unUser2 = unUser3 = unUser4 = unUser5 = unUser6 = unUser7 = unUser8 = unUser9 = unUser10 =
        unUser11 = unUser12 = unUser13 = unUser14 = unUser15 = unUser16 = unUser17 = unUser18 = unUser19 = unUser20 =
        unUser21 = unUser22 = unUser23 = unUser24 = unUser25 = unUser26 = unUser27 = unUser28 = unUser29 = unUser30 =
        unUser31 = unUser32 = unUser33 = unUser34 = unUser35 = unUser36 = unUser37 = unUser38 = unUser39 = unUser40 =
        unUser41 = unUser42 = unUser43 = unUser44 = unUser45 = unUser46 = unUser47 = unUser48 = unUser49 = unUser50 = 0;
    }

    public static void main(String[] args) {
        try {
            test();
        } catch (Throwable e) {
            System.out.println("stack length: " + stackLength);
            throw e;
        }
    }
}
```

运行结果：

![image-20221022135909367](jvm.assets/image-20221022135909367.png)

可以看到，无论是由于栈帧太深还是虚拟机栈容量太小，当新的栈帧内存无法分配时，HotPost都抛SOF。如果是允许动态扩展，相同代码则会导致不同情况。

若测试时不限于单线程，而是不断新建线程，在HotSpot上也会产生OOM。

但这样产生OOM和栈空间是否足够不存在直接的关系，主要取决于os本身内存使用状态。

甚至说这种情况下，给每个线程的栈分配的内存越大，反而越容易产生OOM。

不难理解，os分配给每个进程的内存有限制，比如32位Windows的单个进程最大内存限制为2G。HotSpot提供参数可以控制Java堆和方法区这两部分的内存的最大值，那剩余的内存即为2G（os限制）减去最大堆容量，再减去最大方法区容量，由于程序计数器消耗内存很小，可忽略，若把直接内存和虚拟机进程本身耗费的内存也去掉，剩下的内存就由虚拟机栈和本地方法栈来分配了。因此为每个线程分配到的栈内存越大，可以建立的线程数量越少，建立线程时就越容易把剩下的内存耗尽

原谅我，这个死机了好多次，没试出来，不知道是JDK版本的问题还是因为我的电脑是64位的问题。

代码可以附上

```java
/**
 * VM Args：-Xss2M（这时候不妨设置大些）
 */
public class MyTest {

    public static void main(String[] args) {
        MyTest mytest = new MyTest();
        mytest.stackLeakByThread();
    }

    private void dontStop() {
        while (true) {

        }
    }

    public void stackLeakByThread() {
        while(true){
            Thread thread = new Thread(() -> dontStop());
            thread.start();
        }
    }
}
```





> 方法区和运行时常量池溢出

由于运行时常量池是方法区的一部分，因此这两个区域的溢出测试放到一起进行。







## 3、HotSpot虚拟机对象

### 1、对象的创建

> 类加载

当虚拟机获取到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号应用代表的类是否已被加载，解析和初始化过。如果没有，那必须执行相应的类加载过程。

> 分配内存

在加载检查通过后，开始分配内存，对象所需内存的带下在类加载完成购便可完全确定，为对象分配空间的任务相同于把一块确定大小的内存从java堆中划分出来

这里有两种方式：

- 指针碰撞

  指针碰撞是针对于内存是绝对规整的，这时候只需要把指针进行移动

- 空闲列表

  空闲列表就是针对内存不是规整的，已使用的内存和空间的内存相互交错，这时候虚拟机必须维护一个列表，记录上哪些内存是可用的，在分配的时候从列表中找到一块可用的内存分配给对象实例，并更新列表上的记录。

选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定的。

另一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也不是线程安全的。

可能出现正在给A对象分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存。

解决这个问题有两种方案：

- 对分配内存空间的动作进行同步处理

  实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性

- 把内存分配的动作按照线程划分在不同的空间之中进行

  每个线程在Java堆中预先分配一小块内存，成为本地线程分配缓冲（TLAB） 。那个线程需要分配内存，就在那个线程的TLAB上分配。只有TLAB用完并分配新的TLAB时，才需要同步锁定。

  使用TLAB，可以通过-XX:+/-UseTLAB参数来设定。

> 设置零值

内存分配完之后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）

这一步保证了对象的实例字段在Java代码中可以不赋值就直接使用，程序能访问到这些字段的数据类型所对应的零值



>设置信息

接下来，虚拟机要对对象进行必要的设置，包括是哪个类的实例，如何才能找到类的元数据信息，对象的哈希码，对象的GC分代年龄等信息。

这些信息存放在对象的对象头之中。根据虚拟机当前的运行状态不同，如是否启用偏向锁等。



> init

在上面的工作都完成之后，从虚拟机的视图来看，一个新的对象已经产生了，接下来就是按照程序员的意向进行初始化赋值，这样一个真正可用的对象才算完全产生出来。



### 2、对象的内存布局

对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充

> 对象头

对象头包括两部分信息：

- 第一部分官方称为“Mark Word”

  用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。

  对象头存储的信息是与对象自身定义的数据无关的额外存储成本

  markword数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，它的**最后2bit是锁状态标志位**，用来标记当前对象的状态，对象的所处的状态，决定了markword存储的内容，如下表所示:

  | 状态             | 标志位 | 存储内容                             |
  | ---------------- | ------ | ------------------------------------ |
  | 未锁定           | 01     | 对象哈希码、对象分代年龄             |
  | 轻量级锁定       | 00     | 指向锁记录的指针                     |
  | 膨胀(重量级锁定) | 10     | 执行重量级锁定的指针                 |
  | GC标记           | 11     | 空(不需要记录信息)                   |
  | 可偏向           | 01     | 偏向线程ID、偏向时间戳、对象分代年龄 |

  ![这里写图片描述](jvm.assets/SouthEast.png)

  ![image-20220625172825598](jvm.assets/image-20220625172825598.png)

- 第二部分是类型指针，即对象指向他的类元数据指针

  虚拟机通过这个指针来确定这个对象是哪个类的实例。
  
  这里要注意的是，查找对象的元数据信息并不一定

另外，如果对象是一个数组，在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通的Java对象的元数据信息确定Java对象的大小，但是从数据的元数据中却无法确定数数组的大小。



> 实例数据

这部分树对象真正存储的有效数据，也是在程序代码中所定义的各种类型的字段内容，包括父类和子类

这部分的存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义的顺序的影响

HotSpot 虚拟机默认的分配策略为longs/doubles、 ints、 shorts/chars、 bytes/booleans、 oops

从分配策略中可以看出，相同宽度的字段总是被分配到一起，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前

扩展：

- 如果CompactFileds参数值为true（默认为true），那么子类中较窄的变量也可能会插入到父类变量的空隙之中



> 对齐填充

这部分并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。

因为HotSpot VM 的自动内存管理系统要求对象起始地址必须是8字节的整数倍，也就是说对象的大小必须是8字节的整数倍

对象头部分正好是8子节（32或者64）的整数倍，所以，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。



### 3、对象的访问定位

建立对象是为了使用对象，我们的Java程序需要通过栈上的referece数据来操作堆上的具体对象。

目前主流的访问方式有使用句柄和直接指针两种

- 如果使用句柄访问的话，那么Java堆中将会划出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。

  ![image-20220703211902738](jvm.assets\image-20220703211902738.png)

- 如果使用直接指针访问，那么java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址了

  ![image-20220703212547748](jvm.assets\image-20220703212547748-16568547817751.png)

使用句柄来访问的最大好处就是reference这种存储的是稳定的句柄地址

在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要被修改。

当然，使用指针的速度肯定是更快的，它节省了一次指针定位的时间开销。

对于HotSpot来说，它是使用第二种方式进行对象访问的。



## 3、类加载器

![image-20220622142013155](jvm.assets/image-20220622142013155.png)

## 4、双亲委派机制

1. JVM预定义的三种类型类加载器：

   - **启动（Bootstrap）类加载器**：是用本地代码实现的类装入器，它负责将 `<Java_Runtime_Home>/lib`下面的类库加载到内存中（比如`rt.jar`）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。
   - **标准扩展（Extension）类加载器**：是由 Sun 的 `ExtClassLoader（sun.misc.Launcher$ExtClassLoader）`实现的。它负责将`< Java_Runtime_Home >/lib/ext`或者由系统变量 `java.ext.dir`指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。
   - **系统（System）类加载器**：是由 Sun 的 `AppClassLoader（sun.misc.Launcher$AppClassLoader）`实现的。它负责将系统类路径（`CLASSPATH`）中指定的类库加载到内存中。开发者可以直接使用系统类加载器。

   除了以上列举的三种类加载器，还有一种比较特殊的类型 — 线程上下文类加载器。

2. 双亲委派机制描述
   某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，**依次递归**，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。

3. 步骤

   - 类加载器收到类加载的请求!

   - 将这个请求向上委托给父类加载器去完成，一直向上委托，知道启动类加载器

   - 启动加载器检查是否能够加载当前这个类 能加载就结束，使用当前的加载器，否则，抛出异常，通知子加载器进行加载

   - 重复步骤3

   - Class Not Found ~

   - Java虚拟机的第一个类加载器是Bootstrap，这个加载器很特殊，**它不是Java类，因此它不需要被别人加载，它嵌套在Java虚拟机内核里面，也就是JVM启动的时候Bootstrap就已经启动，它是用C++写的二进制代码（不是字节码）**，它可以去加载别的类。

     这也是我们在测试时为什么发现`System.class.getClassLoader()`结果为null的原因，这并不表示System这个类没有类加载器，而是它的加载器比较特殊，是`BootstrapClassLoader`，由于它不是Java类，因此获得它的引用肯定返回null。

## 5、沙箱安全机制



## 6、PC寄存器



## 11、堆(Heap)

-  一个JVM只有一个堆内存，堆内存的大小是可以调节的。

- 类加载器读取了类文件后，一般会把什么东西放到堆中? 类，方法，常量，变量~，保存我们所有引用类型的真实对象;

- 堆内存中还要细分为三个区域:

  - 新生区(伊甸园区)

  - 养老区

  - 永久区

    ![image-20210307231516768](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210307231516768.png)

```java
public class Demo02{
    public static void main(String[] args){
        //返回虚拟机试图使用的最大内存
        long max = Runtimegetuntime()maxMemory(); //字节 1024 * 1024
        //返回jvm的初始化总内存
        long total = Runtime.getRuntime().totalMemory();
        System.out.println("max="+max+"字节\t"+(max/(double)1024/1024)+"MB”);	
		System.out.println("total="+tota1+"字节\t"+(tota1/(double)1024/1024)+"MB")
        //默认情况下: 分配的总内存 是电脑内存的 1/4，而初始化的内存: 1/64
        //00M解决方法:
			//1试扩大堆内存看结果
			//2.分析内存，看一下那个地方出现了问题(专业工具)

		//-Xms1024m-Xmx1024m-xx:+PrintGCDetails
    }
}
```



## 12、新生区、老年区

GC垃圾回收，主要是在伊甸园区和养老区

Exception in thread "main" java.lang.0utOfMemoryError:Java heap  space  ——>堆内存满了

![image-20210307231656617](C:\Users\86796\AppData\Roaming\Typora\typora-user-images\image-20210307231656617.png)

在一个项目中，突然出现了OOM故障，那么该如何排除~研究为什么出错

- 能够看到代码第几行出错:内存快照分析工具，MAT，Jprofiler 

- Dubug，一行行分析代码!

  

**MAT，Jprofiler 作用**

- 分析Dump内存文件，快速定位内存泄露获得堆中的数据
- 获得大的对象

## 13、永久区

- 逻辑上存在，物理上不存在
- 这个区域常驻内存的。用来存放JDK自身携带的Class对象。Interface元数据，存储的是Java运行时的一些环境或类信息~，
- 这个区域不存在垃圾回收!关闭VM虚拟就会释放这个区域的内存
- 一个启动类，加载了大量的第三方jar包。Tomcat部署了太多的应用，大量动态生成的反射类。不断的被加载。直到内存满，就会出现OOM;
-  jdk1.6之前: 永久代，常量池是在方法区;
-  jdk1.7 永久代，但是慢慢的退化了， 去永久代，常量池在堆中
-  jdk1.8之后:无永久代，常量池在元空间

## 14、堆内存调优

```
  -Xms 设置初始化内存分配大小/164
  -Xmx 设置最大分虎内存，默认 1/4
  -xx:+PrintGCDetails/打印GC垃圾回收信息
  -XX:+HeapDumpOnOutOfMemoryError //OOm DUMP
  -Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError
```



## 15、GC:垃圾回收机制

GC主要围绕三个问题：

- 哪些内存需要回收
- 什么时候回收
- 如何回收



> 哪些内存需要回收

对于程序计数器，虚拟机栈，本地方法栈3个区域随线程而生，栈中的栈帧每一个分配多少内存基本上是在类结构确定下来的时候就已知的。所以这几个区域的内存分配和回收都是具有确定性的，方法结束或者线程结束时，内存自然就随着回收了。

而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存可能也不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的也是这部分的内存。



### 15.1、对象活着吗

垃圾收集器在对堆进行回收前，第一件事就是要确定这些对象之中哪些还存活着。



#### 15.1.1、引用计数算法

> 是什么

给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；

任何时候计数器为0的对象就是不可能再被使用的



> 为什么

引用计数算法的实现简单，判定效率也很高，在大部分情况下都是一个不错的算法

但是主流的Java虚拟机里面没有引用计数算法来管理内存，其中主要的原因就是因为它很难解决对象之间相互循环引用的问题。

```java
objA.instance = objB;
objB.instance = objA;
```

这种情况下，即使这两个对象没有被引用，但是因为相互引用的原因，引用计数并不为0，所以GC无法进行回收



#### 15.1.2、可达性分析算法

在主流的实现中，都是称通过可达性分析算法来判定对象是否存活的

> 是什么

这个算法的基本思路就是通过一系列的的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路劲称为引用链，当一个对象到GC Roots没有任何的引用链相连的时候，则证明此对象是不可用的。

![image-20220704173020463](jvm.assets/image-20220704173020463.png)

Java语言中，可作为GC Roots 的对象包括下面几种

- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中引用的对象



#### 15.1.3、引用

在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用，软引用，弱引用和虚引用

- 强引用就是类似于new对象，这种引用不会被回收
- 软引用是用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列入回收范围进行第二次回收
- 弱引用也是用来描述非必须对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。
- 虚引用是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来去的一个对象实例。设置虚引用的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。



#### 15.1.4、死亡之前

- GC两种类:轻GC(普通的GC) 重GC(全局GC)

- GC题目:

  - JVM的内存模型和分区~详细到每个区放什么?

    ![image-20220704150430101](jvm.assets/image-20220704150430101.png)

  - 堆里面的分区有哪些?Eden，from，to，老年区，说说他们的特点!

    - 每次GC都会将Eden区活的对象移入到幸存区中，一旦Eden区被GC后，就会是空的
    - 幸存区谁空谁是`to`
    - 当一个对象经历了15（默认）次GC之后还没死，就会进入老年区

  - GC的算法有哪些?标记清除法，标记压缩，复制算法，引用计数器，怎么用的?轻GC和重GC分别在什么时候发生?

    - 引用计数器（不管）

    - 标记清除法（压缩）

      ![image-20220704150544822](jvm.assets/image-20220704150544822.png)

    - 复制算法：在两个幸存区复制来复制去

      ![image-20220704150616329](jvm.assets/image-20220704150616329.png)

      ![image-20220704150623119](jvm.assets/image-20220704150623119.png)

    - 内存效率:复制算法>标记清除算法>标记压缩算法(时间复杂度)

    - 内存整齐度:复制算法=标记压缩算法>标记清除算法

    - 内存利用率:标记压缩算法=标记清除算法>复制算法

    - 年轻代:
    
      - 存活率低
      - 复制算法!

    - 老年代:

    - 区域大:存活率
    
    - 标记清除乐标记压缩混合实现 
